{
  "sets": "Một tập hợp là một bộ các phần tử. Các phần tử tạo nên một tập hợp có thể là bất kỳ loại đối tượng toán học nào: số, ký hiệu, điểm trong không gian, đường thẳng, các hình dạng hình học khác, các biến hoặc thậm chí các tập hợp khác. ",
  "element": "Phần tử là các đối tượng hoặc các thành phần cụ thể mà tập hợp đó chứa. Nói cách khác, phần tử là các thành phần riêng lẻ mà tạo nên tập hợp. Một phần tử có thể thuộc hoặc không thuộc vào tập hợp.",
  "pheptoan": "Các toán tử cơ bản trên tập hợp bao gồm các toán tử một ngôi (unary) và hai ngôi (binary) như sau: phép phần bù (complement), phép hợp (union), phép giao (intersection), phép trừ (difference), tích Đecac",
  "quanhe": "Một quan hệ hai ngôi (hay còn gọi là quan hệ nhị phân) trên hai tập A và B là một tập các cặp được sắp (a, b), chứa các phần tử a thuộc A và các phần tử b thuộc B. Đó là một tập con của tích Descartes A × B. Nó mã hóa thông tin quan hệ: một phần tử a có liên quan với một phần tử b khi và chỉ khi cặp (a, b) thuộc về một tập hợp.",
  "tinhchat_quanhe": "Ta gọi một quan hệ R trên tập S là :\n + Phản xạ (reflexive ) : nếu aRa là đúng ∀a ∈ S \n + Đối xứng (symmetric ) : nếu aRb thì bRa \n + Bắc cầu (transitive) : nếu aRb và bRc thì aRc",
  "quanhe_tuongduong": "Một quan hệ R trên tập S có đủ các tính chất phản xạ, đối xứng và bắt cầu được gọi là quan hệ tương đương.",
  "quanhe_baodong": "Giả sử P là tập hợp một số tính chất của các quan hệ, bao đóng P (P - closure) của một quna hệ R trên tập S là quan hệ nhỏ nhất có chứa tất cả các cặp của R thỏa mãn các tính chất trong P.",
  "baodong_batcau": "Bao đóng bắt cầu R+ của R được xác định như sau:\n i) Nếu (a,b) thuộc R thì (a,b) thuộc R+.\n ii) Nếu (a,b) thuộc R+ và (b,c) cũng thuộc R+ thì (a,c) thuộc R+.\n iii) Không còn thêm trong R+.",
  "baodong_phanxa": "Bao đóng phản xạ và bắc cầu R* của R được xác định như sau:\n R* = R+ ∪ {(a,a) | a ∈ S}",
  "quynap": "Giả sử ta cần chứng minh một mệnh đề P(n) với n là một số gnuyeen không âm. Nguyên lý quy nạp toán học cho P(n) được chứng minh theo 2 bước sau:\n i) P(0), và \n ii) P(n-1) kéo theo P(n), ∀n ≥ 1\n Bước (i) được gọi là cơ sở quy nạp, bước (ii) được gọi là bước quy nạp với P(n-1) là giả thiết quy nạp.",
  "dothi": "Một đồ thị, ký hiệu G = (V,E), bao gồm một tập hữu hạn các đỉnh V (còn gọi là nút) và một tập các cạnh E nối giữa 2 nút.",
  "duongdi": "Một đường đi (path) trên một đồ thị là dãy các đỉnh v1,v2,...,vk, k ≥ 1, sao cho trong đó có một cạnh (vi,vi+1) cho mỗi i, 1 ≤ i ≤ k",
  "dodaiduongdi": "Độ dài đường đi là k-1. Nếu v1= vk thì đường đi là một chu trình.",
  "dothicohuong": "Một đồ thị có hướng cũng là dnajg đồ thị được xác định bởi G = (V,E), trong đó V là tập các đỉnh, còn E là tập các đỉnh có thứ tự gọi là các cung ( hay các đường nối có hướng giữa 2 đỉnh). Ký hiệu một cung từ v đến w có dạng v → w",
  "cay": "Cây (cây định hướng có thứ tự) là một đồ thị có hướng với các tính chất sau:\n i) Có một nút gọi là nút gốc.\n ii) Mỗi nút còn lại đều được dẫn ra từ một nút cha ở trên nó:\n - Các nút có dẫn ra nút con sau nó được gọi là nút trung gian hay nút trong.\n - Các nút không dẫn ra nút con gọi là nút lá.\n iii) Thứ tự duyệt trên cây là từ trái sang phải.",
  "ngonngu": "Ngôn ngữ, một cách không chính xác là một hệ thống thích hợp cho việc biểu thị các ý nghĩ, các sự kiện hay các khái niệm, bao gồm một tập các ký hiệu và các quy tắc để vận dụng chúng.",
  "bochucai": "Một bộ chữ cái (bộ ký hiệu ) là một tập hợp không rỗng , ký hiệu là Σ. Các phần tử của một bộ chữ cái Σ được gọi là các ký hiệu (symbols).",
  "kyhieu": "Một ký hiệu (symbols) là một thực thể trừu tượng mà ta sẽ không định nghĩa được một cách hình thức.",
  "chuoi": "Một chuỗi (string) hay từ (word) trên bộ chữ cái Σ là một dãy hữu hạn gồm một số lớn hơn hay bằng không các ký hiệu của Σ, trong đó một ký hiệu có thể xuất hiện vài lần.",
  "dodai": "Độ dài của một chuỗi w, ký hiệu là |w| là số các ký hiệu tạo thành chuỗi w.",
  "chuoi_rong": "Chuỗi rỗng (ký hiệu là ξ) là chuối không có ký hiệu nào, vì vậy |ξ|=0",
  "tiento_hauto": "Tiền tố của một chuỗi là một chuỗi con bất kỳ nằm ở đầu chuỗi và hậu của một chuỗi là chuỗi con nằm ở cuối chuỗi.",
  "tiento_hauto_thucsu": "Tiền tố và hậu tố của một chuỗi khác hơn chính chuỗi đó ta gọi là tiền tố va fhajau tố thực sự.",
  "chuoinoiket": "Chuỗi nối kết (ghép ) từ hai chuỗi con là một chuỗi tạo được bằng cách viết chuỗi thứ nhất sau đó là chuỗi thứ hai (không có khoảng trống ở giữa)",
  "chuoidao_nguoc": "Chuỗi đảo ngược của chuỗi w, ký hiệu là wr là chuỗi được viết theo thứ tự ngược lại, nghĩa là nếu w= a1,a2,...,an thì wr= an,an-1,...,a1. Hiển nhiên ξr = ξ ",
  "ngon_ngu_hinhthuc": "Một ngôn ngữ (hình thức) L là một tập hợp csac chuỗi của các ký hiệu từ một bộ chữ cái Σ nào đó",
  "pheptoan_ngonngu": "Từ các ngôn ngữ có trước, ta có thể thu được các ngôn ngữ mới nhờ áp dụng các phép toán trên ngôn ngữ. Trước hết, vì ngôn ngữ là một tập hợp, nên mọi phép toán trên tập hợp như : hợp (union),giao (intersection) và hiệu (difference)... đều có thể áp dụng lên các ngôn ngữ. Ngoài ra còn có các phép toán khác như : phép phần bù (complement), phép kết nối ( concatenation) , phép bao đóng (closure).",
  "phanbu": "Phép phần bù (complement) của một ngôn ngữ L trên bộ chữ cái Σ đươc định nghĩa như sau: L = Σ* - L",
  "phepnoiket": "Phép nối kết (concatenation) của hai ngôn ngữ Li trên bộ chữ cái Σi và L2 trên  bộ chữ cái Σ2 được định nghĩa bởi: L1L2 = { w1w2 | w1 ∈ L1 và w2 ∈ L2} trên bộ chữ cái Σ1 ∪ Σ2",
  "phepbaodong": "Phép bao đóng (closure) : trong nhiều trường hợp, người ta muốn thành lập một ngôn ngữ bằng cách nối kết các chuỗi ( với số lượng bất kỳ) lấy trong một ngôn ngữ L cho trước, các phép toán đó như sau:\n - Bao đóng (Kleene) của ngôn  ngữ L, k hiệu L* được định nghĩa là hợp của mọi tập tích trên L.\n - Bao đóng dương (positive) của ngôn ngữ L, ký tự L+ được định nghĩa là hợp của mọi tích dương trên L.",
  "vanpham": "Văn phạm (grammar) là một tập hợp các quy tắc và cấu trúc ngữ pháp mà ngôn ngữ được xây dựng dựa trên đó. Nó xác định cách các thành phần ngôn ngữ được kết hợp và xếp chồng lên nhau để tạo thành các câu hoặc văn bản hợp lệ.",
  "vanpham_cautruc": "Văn phạm cấu trúc G là một hệ thống gồm bốn thành phần xác định như sau G(V,T,P,S), trong đó: \n - V : tập hợp các biến hay các ký hiệu chưa kết thúc.\n - T : tập hợp các ký hiệu kết thúc.\n - P : tập hữu hạn các quy tắc ngữ pháp được gọi là các luất sinh . mỗi luật sinh được biểu diễn dưới dạng a -> b với a,b là các chuỗi (V ∈ T)*.\n - S : ký tự chưa kết thúc dùng làm ký hiệu bắt đầu.",
  "danxuat": "Từ văn phạm, để sinh ra được các câu (từ) , ta định nghĩa khái niệm dẫn xuất như sau :\n Nếu a ➝ B là một luật sinh thì γaδ ⟹ γbδ gọi là một dẫn xuất trực tiếp, có nghĩa là áp dụng luật sinh a ➝ b vào chuỗi γaδ để sinh ra chuỗi γbδ.",
  "ngonngu_vp": "Ngôn ngữ của văn phạm G (V,T,P,S) là tập hợp các chuỗi kí hiệu kết thúc w ∈ T* được sinh ra từ kí hiệu bắt đầu S của văn phạm bởi các luật sinh thuộc tập P, ký hiệu là L(G).",
  "vpham_tuong_duong": "Hai văn phạm sinh ra cùng một ngôn ngữ thì gọi là văn phạm tương đương",
  "vp_loai0": "Một văn phạm không cần thỏa ràng buộc nào trên tập các luật sinh được gọi là văn phạm loại 0 hay còn được gọi là văn phạm không hạn chế ( Unrestricted Grammar).",
  "vp_loai1": "Nếu văn phạm G có các luật sinh dạng a ➝ B và thỏa |B| ≥ |a| thì G là văn phạm loại 1 hoặc còn được gọi là văn phạm cả, mgiwx cảm CSG ( Context-Sensitive Grammar).",
  "vp_loai2": "Nếu văn phạm G có các luật sinh dạng A ➝ a với A là một biến đơn và a là một cuỗi các ký hiệu ∈ (V ⋃ T)* thì G là văn phạm loại 2 hoặc còn được gọi là văn phạm phi ngữ cảnh CFG ( Context-Free Grammar).",
  "vp_loai3": "Nếu văn phạm G có mọi luật sinh dạng tuyến tính phải A ➝ wB hoặc A ➝ w với A,B là các biến đơn và w là chuỗi ký hiệu kết thúc ( có thể rỗng); hoặc có dạng tuyến tính trái A ➝ Bw hoặc A ➝ w thì G là văn phạm loại 3 hay còn được gọi là văn phạm chính quy RG ( Regular Grammar).",
  "otomat": "Một otomat, hay còn gọi là máy trạng thái hữu hạn (finite state machine), là một mô hình tính toán trừu tượng được sử dụng để mô tả và phân tích cấu trúc của các chuỗi ký tự thuộc vào một ngôn ngữ cụ thể.\n Otomat bao gồm một tập hữu hạn các trạng thái, một tập hữu hạn các ký tự đầu vào (gọi là bảng chữ cái), một trạng thái ban đầu, các trạng thái kết thúc (hoặc trạng thái chấp nhận), và các quy tắc chuyển trạng thái.\n Có hai loại otomat chính là otomat đơn định và otomat không đơn định.",
  "dfa": "DFA là viết tắt của Deterministic Finite Automaton, là một otomat hữu hạn đơn định - gọi tắt là FA- gồm một tập hữu hạn các trạng thái và một tập các phép chuyển từ trạng thái này tới trạng thái khác trên các ký hiệu nhập được chọn từ một bộ chữ cái Σ nào đó.",
  "nfa": "NFA là viết tắt của Nondeterministic Finite Automaton, à một loại otomat hữu hạn, bao gồm một tập hữu hạn các trạng thái và một tập các phép chuyển từ trạng thái này sang trạng thái khác trên các ký hiệu đầu vào được chọn từ một bộ chữ cái Σ nhất định, tương tự như DFA.\n Tuy nhiên, điểm khác biệt quan trọng giữa NFA và DFA là NFA cho phép có các phép chuyển phi đơn định, có nghĩa là tại một trạng thái và một ký hiệu đầu vào cụ thể, NFA có thể chuyển đổi sang nhiều trạng thái khác nhau hoặc không chuyển đổi trạng thái",
  "nfa_ξ" : "NFA ới ξ-dịch chuyển là bộ 5 thành phần (Q,Σ,δ,q0,F), với tất cả thành phần có ý nghĩa như NFA nhưng hàm chuyển δ là ánh xạ từ Q x (Σ ⋃ {ξ}) ➝ 2^Q.",
  "ham_morong_ξ": "Ta mở rộng hàm chuyển δ thành hàm chuyển δ* ánh xạ từ Q x Σ*➝2^Q. δ*(q,w) chứa tất cả các trạng thái p sao cho có thể di từ q tới p theo đường đi nhãn w ( có thể chứa cạnh nhãn ξ)",
  "dfatunfa": "1.Khởi tạo DFA rỗng với tập trạng thái Q' (ban đầu chỉ chứa trạng thái rỗng), bảng chữ cái Σ, hàm chuyển trạng thái δ', trạng thái ban đầu q0' (tương ứng với trạng thái rỗng của NFA) và tập trạng thái kết thúc F' (ban đầu rỗng).\n2. Tạo một hàng đợi (queue) và thêm q0' vào hàng đợi.\n 3.Lặp cho đến khi hàng đợi trống:\na. Lấy một trạng thái từ hàng đợi và gọi nó là T.\nb. Với mỗi ký tự a trong bảng chữ cái Σ:\n\nTính toán tập trạng thái U là tập hợp các trạng thái mà NFA có thể chuyển đến từ các trạng thái trong T qua a.\nNếu U không thuộc vào tập trạng thái Q' của DFA, thêm U vào Q' và hàng đợi.\nThêm cặp (T, a, U) vào hàm chuyển trạng thái δ' của DFA.\nc. Nếu T chứa một trạng thái kết thúc của NFA, thêm T vào tập trạng thái kết thúc F' của DFA.\n 4. DFA được xây dựng hoàn tất. Trạng thái ban đầu của DFA là q0'. Tập trạng thái Q' của DFA là tất cả các tập con của Q mà đã được xây dựng trong quá trình chuyển đổi. Tập trạng thái kết thúc F' của DFA là tất cả các tập con của Q mà chứa ít nhất một trạng thái kết thúc của NFA.",
  "bieuthuc_chinhquy": "Lớp ngôn ngữ được chấp nhận bởi otomat hữu hạn cũng có thể được mô tả thông qua một dạng biểu thức ngắn gọn và súc tích gọi là biểu thức chính quy.",
  "thutu_uutien": "Trong khi viết biểu thức chính quy ta có thể bỏ bớt các dấu ngoặc đơn với lưu ý rằng thứ tự ưu tiên của các phép toán xếp theo thứ tự giảm dần là : phép bao đóng, phép nối kết, phép hợp.",
  "tinhchat_daiso_bieuthuccq": "Cho r,s,t là các biểu thức chính quy thì ta có các đẳng thức sau :\n 1. r + s = s +r\n 2. r + r = r\n 3. r + (s+t) = (r+s) +t\n 4. r(st)= (rs)t\n 5. r(s+t) = rs + rt\n 6. (r+s)t = rt + st\n 7. rξ = ξr = r\n 8. r⊘ = ⊘r = ⊘\n 9. r + ⊘ = r\n 10. ⊘* =⊘\n 11. (ξ+r)* = r*\n 12. r + r* = r*\n 13. (r*)* = r*\n 14. (r*s*)* = (r+s)*",
  "ungdung_otomat_hh": "Có nhiều kiểu phần mềm thiết kế nhằm đặc tả sự chuyển đổi tự động từ dạng biểu thức chính quy sang việc cài đặt máy tính một cách hiệu quả tương ứng với otomat hữu hạn. Hai ứng dụng phổ biến là : bộ phân tích từ vựng và trình soạn thảo văn bản.",
  "vanpham_tt_trai": "Một văn phạm G(V,T,P,S) được gọi là tuyến tính trái ( left-linear) nếu tất cả các luấ tính của nó có dạng :\n A ➝ Bw \n A ➝ w \n Trong đó A,B là các biến thuộc V; w là mọt cuỗi các ký hiệu kết thúc thuộc T* ( có thể rỗng).",
  "vanpham_tt_phai": "Một văn phạm G(V,T,P,S) được gọi là tuyến tính phải ( right-linear) nếu tất cả các luấ tính của nó có dạng :\n A ➝ wB \n A ➝ w \n Trong đó A,B là các biến thuộc V; w là mọt cuỗi các ký hiệu kết thúc thuộc T* ( có thể rỗng).",
  "vanpham_chinhquy": "Một văn phạm được gọi là văn phạm chính quy nếu nó thuộc dạng văn phạm tuyến tính trái hoặc tuyến tính phải.",
  "bode_bom": "Nếu L là tập hợp chính quy thì có tồn tại hằng số n sao cho nếu z là một từ bất kỳ thuộc L và | z | ≤ n, ta có thể viết z = uvw với | uv | ≤ n, | v | ≥ 1 và ∀i ≥ 0, ta có uviw ∈ L.\n Hơn nữa n không lớn hơn số trạng thái của FA nhỏ nhất chấp nhận L.",
  "ungdung_bode_bom": "Bổ đề bơm rất có hiệu quả trong việc chứng tỏ một tập hợp không là tập hợp chính quy. Phương pháp chung để ứng dụng nó dùng phương pháp chứng minh “phản chứng” theo dạng sau :\n 1) Chọn ngôn ngữ mà bạn cần chứng tỏ đó không là ngôn ngữ chính quy. \n2) Chọn hằng số n, hằng số được đề cập đến trong bổ đề bơm. \n3) Chọn chuỗi z thuộc L. Chuỗi z phải phụ thuộc nghiêm ngặt vào hằng số n đã chọn ở bước 2. \n4) Giả thiết phân chuỗi z thành các chuỗi con u, v, w theo ràng buộc | uv | ≤ n và | v | ≥ 1 \n5) Mâu thuẫn sẽ phát sinh theo bổ đề bơm bằng cách chỉ ra với u, v và w xác định theo giả thiết, có tồn tại một số i mà ở đó uviw ∉ L. Từ đó có thể kết luận rằng L không là ngôn ngữ chính quy. Chọn lựa giá trị cho i có thể phụ thuộc vào n, u, v và w. ",
  "tinh_chat_dong_thcq": "1.Tập hợp chính quy đóng với các phép toán: hợp, nối kết và bao đóng Kleen.\n 2.Tập hợp chính quy đóng với phép lấy phần bù. Tức là, nếu L là tập chính quy và L ⊆ Σ* thì Σ* - L là tập chính quy.\n 3.Tập hợp chính quy đóng với phép giao.",
  "giai_thuat_xd_thcq": "i) Tập hợp các chuỗi được chấp nhận bởi ôtômát M có n trạng thái là:\n 1) Không rỗng nếu và chỉ nếu ôtômát chấp nhận một chuỗi có độ dài < n. \n2) Vô hạn nếu và chỉ nếu ôtômát chấp nhận một chuỗi có độ dài l với n ≤ l < 2n.\n\n ii) Có giải thuật để xác định hai ôtômát tương đương (chấp nhận cùng một ngôn ngữ).",
  "vanphamphi_ngucanh": "Văn phạm phi ngữ cảnh là một tập hợp hữu hạn các biến (còn gọi là các ký hiệu chưa kết thúc), mỗi biến biểu diễn một ngôn ngữ. Ngôn ngữ được biểu diễn bởi các biến được mô tả một cách đệ quy theo thuật ngữ của một khái niệm khác gọi là ký hiệu kết thúc. Quy tắc quan hệ giữa các biến gọi là luật sinh. Mỗi luật sinh có dạng một biến ở vế trái sinh ra một chuỗi có thể gồm biến lẫn các ký hiệu kết thúc trong văn phạm.",
  "caydan_xuat": "Để dễ hình dung sự phát sinh ra các chuỗi trong văn phạm phi ngữ cảnh, ta thường diễn tả một chuỗi dẫn xuất qua hình ảnh một cây. Một cách hình thức, ta định nghĩa như sau:\nCho văn phạm G (V, T, P, S). Cây dẫn xuất (hay cây phân tích cú pháp) của G được định nghĩa như sau :\n i) Mỗi nút (đỉnh) có một nhãn, là một ký hiệu ∈ (V ∪ T ∪ {ε}) \nii) Nút gốc có nhãn là ký hiệu bắt đầu S. \niii) Nếu nút trung gian có nhãn A thì A ∈ V \niv) Nếu nút n có nhãn A và các đỉnh n1, n2, ..., nk là con của n theo thứ tự từ trái sang phải có nhãn lần lượt là X1, X2, ..., Xk thì A → X1X2 ... Xk là một luật sinh trong tập luật sinh P.",
  "danxuat_caydanxuat": "Quan hệ giữa dẫn xuất và cây dẫn xuất: \n Nếu G (V, T, P, S) là một văn phạm phi ngữ cảnh thì S ⇒* α nếu và chỉ nếu có cây dẫn xuất trong văn phạm sinh ra α",
  "vanpham_moho": "Một văn phạm phi ngữ cảnh G có nhiều hơn một cây dẫn xuất cho cùng một chuỗi w, thì G được gọi là văn phạm mơ hồ (ambiguity). Dĩ nhiên, cũng có thể nói rằng văn phạm G là mơ hồ nếu có một chuỗi w được dẫn ra từ ký hiệu bắt đầu S với hai dẫn xuất trái hoặc hai dẫn xuất phải",
  "luat_sinh_ε": "Một luật sinh có dạng A → ε gọi là luật sinh ε.\n Ta xét đến việc loại bỏ các luật sinh này. Nếu ε ∈ L(G) thì không thể loại được tất cả các luật sinh ε, nhưng nếu ε ∉ L(G) thì có thể. Phương pháp loại bỏ dựa trên việc xác định liệu một biến A có dẫn xuất A ⇒* ε hay không ? Nếu có, ta gọi A là biến rỗng (nullable). Ta có thể thay thế mỗi luật sinh B → X1X2 ... Xn bằng tất cả các luật sinh được định dạng bởi việc xóa bỏ tập hợp con các biến Xi rỗng, nhưng không bao gồm luật sinh B → ε, ngay cả khi tất cả các Xi đều là biến rỗng.",
  "luat_sinh_donvi": "Một luật sinh có dạng A → B với A, B đều là biến gọi là luật sinh đơn vị",
  "dangchuan_chomsky": "Dạng chuẩn Chomsky hay CNF :\n Một ngôn ngữ phi ngữ cảnh bất kỳ không chứa ε đều được sinh ra bằng một văn phạm nào đó mà các luật sinh có dạng A → BC hoặc A → a, với A, B, C là biến còn a là ký hiệu kết thúc.",
  "dangchuan_greibach": "Dạng chuẩn Greibach hay GNF :\n Trong dạng chuẩn Greibach, các luật sinh chỉ có một dạng duy nhất là A → aα, trong đó A là một biến, a là một ký tự thuộc bảng chữ cái, và α là một chuỗi các biến và ký tự thuộc bảng chữ cái. Đặc biệt, α không thể là ε (chuỗi rỗng). ",
  "tinhchat_phi_ngucanh": "Tính chất của ngôn ngữ phi ngữ cảnh gồm : bổ đề bơm và tính chất đóng",
  "otomat_dayxuong": "Ôtômát đẩy xuống ( PDA) có một bộ điều khiển hữu hạn và một Stack. Stack chứa một chuỗi các ký hiệu thuộc một bộ chữ cái nào đó. Ký hiệu bên trái nhất của chuỗi xem như ký 97hiệu tại đỉnh Stack. PDA không đơn định nếu như có một số hữu hạn các lựa chọn phép chuyển trong mỗi lần chuyển.",
  "hinh_thai_pda": "Để hình thức hóa cấu hình của một PDA với một PDA cụ thể, ta định nghĩa một hình thái (ID). ID phải ghi nhớ trạng thái và nội dung của Stack.\n ID là một bộ ba (q, w, γ), trong đó q là trạng thái, w là chuỗi nhập và γ là chuỗi các ký hiệu Stack.\n Nếu M (Q, Σ, Γ, δ, q0, Z0, F) là một PDA, ta nói : (q, aw, Zα) ⊢M (p, w, βα) nếu δ(q, a, Z) chứa",
  "ngon_ngu_pda": "Với PDA M (Q, Σ, Γ, δ, q0, Z0, F), ta định nghĩa :\n Ngôn ngữ được chấp nhận bởi trạng thái kết thúc là: L (M) = {w | (q0, w, Z0) ⊢* (p, ε, γ) với p ∈ F và γ ∈ Γ*}\n Ngôn ngữ được chấp nhận bởi Stack rỗng là : N(M) = {w | (q0, w, Z0) ⊢* (p, ε, ε) với p ∈ Q}. \nKhi có sự chấp nhận bằng Stack rỗng thì tập trạng thái kết thúc là không còn cần thiết vì vậy ta ký hiệu tập trạng thái kết thúc F là ∅.\n",
  "turing": "Một mô hình hình thức cho một thủ tục hiệu quả sẽ có những đặc tính cụ thể. Đầu tiên, mỗi thủ tục sẽ được mô tả một cách hữu hạn. Tiếp đó, thủ tục sẽ được phân thành một số bước độc lập, mà mỗi bước thực thi một vấn đề. Nguyên tắc này cũng được hình thức trong mô hình máy Turing.",
  "mo_hinh_turing": "Máy Turing có rất nhiều dạng đồng khả năng, nghĩa là có nhiều mô hình và định nghĩa khác nhau cho máy Turing nhưng tất cả chúng đều tương đương nhau. Song, nói chung mô hình cơ bản của một máy Turing gồm :\n - Một bộ điều khiển hữu hạn.\n - Một băng được chia thành các ô.\n- Một đầu đọc-viết, mỗi lần đọc có thể duyệt qua một ô trên băng để đọc hay viết ký hiệu.",
  "hinhthuc_turing": "Định nghĩa: TM là một hệ thống M (Q, ∑, Γ, δ, q0, B, F), trong đó:\n - Q : tập hữu hạn các trạng thái. \n- ∑: bộ ký hiệu nhập. \n- Γ : tập hữu hạn các ký tự được phép viết trên băng. \n- B : ký hiệu thuộc Γ dùng chỉ khoảng trống trên băng (Blank). \n- δ : hàm chuyển ánh xạ : Q × Γ → Q × Γ × {L, R, ∅} (δ có thể không xác định với một vài đối số) \n- q0 ∈ Q là trạng thái bắt đầu \n- F ⊆ Q là tập các trạng thái kết thúc",
  "ngon_ngu_turing": "Ngôn ngữ được chấp nhận bởi một máy Turing được gọi là ngôn ngữ đệ qui liệt kê - recursively enumerable (r.e) Đó là một lớp ngôn ngữ rất rộng, nó thực sự chứa ngôn ngữ phi ngữ cảnh CFL và một số ngôn ngữ mà không thể xác định các thành phần một cách máy móc. Nếu L(M) là một ngôn ngữ như vậy thì bất kỳ một máy Turing nào nhận diện L(M) cũng sẽ không dừng trên một số input không thuộc L(M).",
  "ngonngu_dequy": "Một lớp con của lớp ngôn ngữ đệ qui liệt kê, trong đó mọi ngôn ngữ đều được chấp nhận bởi ít nhất một máy Turing dừng trên mọi input. Lớp ngôn ngữ này gọi là lớp ngôn ngữ đệ qui - recursive sets.",
  "turing_2chieu": "Máy Turing với băng vô hạn hai chiều cũng tương tự như mô hình gốc (TM vô hạn một chiều băng), chỉ khác là băng của nó không có cận trái như mô hình gốc, nghĩa là ta xem như TM có vô hạn Blank ở cả hai đầu băng. Vì thế hàm δ được mở rộng thêm bằng cách xét thêm các trường hợp đặc biệt tại cận trái như sau :\n Nếu δ(q, X) = (p, Y, L) thì qXα ⊢ pBYα\n Nếu δ(q, X) = (p, B, R) thì qXα ⊢ pα",
  "turing_khong_dondinh": "Máy Turing không đơn định có mô hình tương tự như mô hình gốc nhưng điểm khác biệt ở chỗ là trong mỗi lần chuyển, máy Turing có thể lựa chọn một trong một số hữu hạn các trạng thái kế tiếp, lựa chọn hướng chuyển đầu đọc, và lựa chọn ký hiệu in ra trên băng để thay thế ký hiệu vừa đọc được.",
  "turing_nhieuchieu": "Máy Turing nhiều chiều gồm một bộ điều khiển hữu hạn, nhưng băng của nó là một mảng k chiều vô hạn về cả 2k phía. Với một số k nào đó, phụ thuộc vào trạng thái và một ký hiệu được đọc, máy thay đổi trạng thái, in một ký hiệu mới tại ô đang đọc và dịch chuyển đầu đọc theo một trong 2k phía.",
  "turing_nhieudaudoc": "Máy Turing nhiều đầu đọc có k đầu đọc được đánh số từ 1 đến k với k là một số hữu hạn nào đó, nhưng chỉ có một băng input. Một phép chuyển của máy Turing phụ thuộc vào trạng thái và các ký tự được đọc bởi mỗi đầu băng. Mỗi đầu dịch chuyển một cách độc lập sang trái, sang phải hoặc đứng yên.",
  "church": "Giả thuyết rằng khái niệm trực giác “Hàm tính được” (computable function) có thể được định nghĩa bằng lớp các hàm đệ quy bộ phận là giả thuyết Church hay còn được gọi là luận đề Church - Turing",
  "lba": "Ta gọi Ôtômát tuyến tính giới nội (Linear Bounded Automata - LBA) là một máy Turing không đơn định và không có khả năng nới rộng vùng làm việc ra khỏi mút trái và mút phải của chuỗi nhập. Nó phải thỏa hai điều kiện sau :\n 1) Bộ chữ cái nhập của nó có chứa thêm hai ký hiệu đặc biệt ⊄ và $ dùng làm ký hiệu đánh dấu mút trái và mút phải. \n2) LBA không thực hiện phép chuyển sang trái (L) từ ⊄ và không thực hiện phép chuyển sang phải (R) từ $, và cũng không viết các ký hiệu khác lên ⊄ và $.",
  "hinhthuc_lba": "Một cách hình thức, LBA là một hệ thống M(Q, Σ, Γ,δ,qo,⊄, $, F), trong đó các thành phần Q, Σ, Γ, qo, F vẫn như đã định nghĩa ở máy Turing, còn ⊄, $ ∈ Σ và hàm chuyển : \nδ: Q × Γ → (Q × Γ × { L, R}) phải thỏa mãn điều kiện: \n- Nếu (p, Y, E) ∈ δ(q, ⊄) thì Y = ⊄ và E = R \n- Nếu (p, Y, E) ∈ δ(q, $) thì Y = $ và E = L",
  "vp_cam_ngucanh": "Ta gọi văn phạm cảm ngữ cảnh (Context Sensitive Grammar - CSG) là một hệ thống G (V, T, P, S), trong đó:\n 1) V là một tập hữu hạn các biến hay ký hiệu không kết thúc. \n2) T là một tập hữu hạn các ký hiệu cuối, V ∩ T = ∅ \n3) P là tập hữu hạn các luật sinh dạng α → β trong đó α, β ∈ (V ∪ T)*, chuỗi α phải có chứa biến và ràng buộc ⎟ α⎟ ≤ ⏐β⏐ \n4) S ∈ V là ký hiệu bắt đầu.\n Ta định nghĩa ngôn ngữ do văn phạm cảm ngữ cảnh G sinh ra là :\n L(G) = { w | w ∈ Σ* và S ⇒* w}"
}